#include <check.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "misc.c"
#include "s21_string.h"
#include "s21_strlen.c"
#include "s21_strstr.c"
#include "s21_strtok.c"
#include "s21_trim.c"

#test s21_strlen_test
char *test1 = "Hello world";
char *test2 = "123456789\0";
char *test3 = "    ";
char *test4 = "";
ck_assert_int_eq(strlen(test1), s21_strlen(test1));
ck_assert_int_eq(strlen(test2), s21_strlen(test2));
ck_assert_int_eq(strlen(test3), s21_strlen(test3));
ck_assert_int_eq(strlen(test4), s21_strlen(test4));

// ##################################################################### //
// ----------------------------- s21_strstr ---------------------------- //
// ##################################################################### //

// Тест 1: Строка найдена
#test s21_strstr_test
const char *haystack = "Hello, world!";
const char *needle = "world";
// Оригинальная функция для сравнения
const char *expected = strstr(haystack, needle);
char *result = s21_strstr(haystack, needle);

// Проверяем, что результат не NULL, если ожидаемый тоже не NULL
ck_assert_ptr_nonnull(result);
ck_assert_ptr_nonnull(expected);

// Проверяем, что возвращенные указатели указывают на один и тот же участок
// памяти haystack
ck_assert_ptr_eq(result, expected);

// Проверяем, что строки, на которые указывают результат и ожидание, идентичны
ck_assert_str_eq(result, expected);

// Тест 2: подстрока не найдена
#test test_s21_strstr_not_found
const char *haystack = "Hello, world!";
const char *needle = "universe";
const char *expected = strstr(haystack, needle);  // Ожидаем NULL

char *result = s21_strstr(haystack, needle);

// Проверяем, что результат равен ожидаемому (NULL)
ck_assert_ptr_null(result);
ck_assert_ptr_null(expected);

// Тест 3: пустая подстрока (needle)
#test test_s21_strstr_empty_needle
const char *haystack = "Hello, world!";
const char *needle = "";  // Пустая строка
// Стандарт strstr для пустой needle часто возвращает haystack.
const char *expected = "Hello, world!";  // "Hello, world!"

char *result = s21_strstr(haystack, needle);

// Проверяем, что результат равен ожидаемому haystack
ck_assert_str_eq(result, expected);

// Тест 4: пустая строка (haystack)
#test test_s21_strstr_empty_haystack
const char *haystack = "";  // Пустая строка
const char *needle = "test";
// Стандарт strstr для пустой haystack часто возвращает NULL.
const char *expected = NULL;  // Ожидаем NULL

char *result = s21_strstr(haystack, needle);

// Проверяем, что результат равен ожидаемому (NULL)
ck_assert_ptr_null(result);
ck_assert_ptr_null(expected);

// Тест 5: needle равен haystack
#test test_s21_strstr_needle_equal_haystack
const char *haystack = "test";
const char *needle = "test";
const char *expected = strstr(haystack, needle);  // Ожидаем haystack

char *result = s21_strstr(haystack, needle);

// Проверяем, что результат не NULL
ck_assert_ptr_nonnull(result);
ck_assert_ptr_nonnull(expected);

// Проверяем, что возвращенные указатели указывают на начало haystack
ck_assert_ptr_eq(result, haystack);
ck_assert_ptr_eq(expected, haystack);

// Проверяем, что строки совпадают
ck_assert_str_eq(result, expected);

// Тест 6: needle в конце haystack
#test test_s21_strstr_needle_at_end
const char *haystack = "start middle end";
const char *needle = "end";
const char *expected = strstr(haystack, needle);  // Оригинальная функция

char *result = s21_strstr(haystack, needle);

// Проверяем, что результат не NULL
ck_assert_ptr_nonnull(result);
ck_assert_ptr_nonnull(expected);

// Проверяем, что возвращенные указатели совпадают
ck_assert_ptr_eq(result, expected);

// Проверяем, что строки совпадают
ck_assert_str_eq(result, expected);

// Тест 7: needle несколько раз в haystack
#test test_s21_strstr_multiple_occurrences
const char *haystack = "abababab";
const char *needle = "aba";
const char *expected = strstr(
    haystack, needle);  // Оригинальная функция (находит первое вхождение)

char *result = s21_strstr(haystack, needle);

// Проверяем, что результат не NULL
ck_assert_ptr_nonnull(result);
ck_assert_ptr_nonnull(expected);

// Проверяем, что возвращенные указатели совпадают (находят первое вхождение)
ck_assert_ptr_eq(result, expected);

// Проверяем, что строки совпадают
ck_assert_str_eq(result, expected);

// Тест 8: Смешанные символы (включая пробелы, знаки препинания)
#test test_s21_strstr_mixed_chars
const char *haystack = "This is a test string, with punctuation! 123.";
const char *needle = "string, with";
const char *expected = strstr(haystack, needle);  // Оригинальная функция

char *result = s21_strstr(haystack, needle);

// Проверяем, что результат не NULL
ck_assert_ptr_nonnull(result);
ck_assert_ptr_nonnull(expected);

// Проверяем, что возвращенные указатели совпадают
ck_assert_ptr_eq(result, expected);

// Проверяем, что строки совпадают
ck_assert_str_eq(result, expected);

// Тест9: haystack короче needle
#test test_s21_strstr_haystack_shorter
const char *haystack = "short";
const char *needle = "longer string";
const char *expected = strstr(haystack, needle);  // Ожидаем NULL

char *result = s21_strstr(haystack, needle);

// Проверяем, что результат равен ожидаемому (NULL)
ck_assert_ptr_null(result);
ck_assert_ptr_null(expected);

// ##################################################################### //
// ------------------------- Test for s21_trim ------------------------- //
// ##################################################################### //

// Тест 1: Источник NULL
#test test_test_trim_null_source
void *result = s21_trim(NULL, " \t");
ck_assert_ptr_null(result);  // Ожидаем NULL в результате

// Тест 2: Символы для удаления NULL (должен обрезать пробелы по умолчанию?)
#test test_trim_null_chars
void *result = s21_trim("  hello  ", NULL);
if (result != NULL) {
  ck_assert_str_eq(result, "hello");  // Ожидаем обрезку пробелов
  free(result);
}

// Тест 3: Пустая строка источника
#test test_trim_empty_source
void *result = s21_trim("", "abc");
ck_assert_ptr_nonnull(result);  // Должен вернуть указатель (возможно, на "")
ck_assert_str_eq(result, "");   // Ожидаем пустую строку
free(result);

// Тест 4: Нет символов для удаления
#test test_trim_no_trimmable_chars
void *result = s21_trim("hello", "xyz");
ck_assert_ptr_nonnull(result);
ck_assert_str_eq(result, "hello");  // Строка не должна измениться
free(result);

// Тест 5: Удаление символов в начале в конце
#test test_trim_leading_chars
void *result = s21_trim("xxxHelloyyy", "xy");
ck_assert_ptr_nonnull(result);
ck_assert_str_eq(result, "Hello");  // Только начальные 'x' удалены
free(result);

// Тест 7: Удаление символов и в начале, и в конце
#test test_trim_both_leading_and_trailing
void *result = s21_trim("  hello  world  ", " ");
ck_assert_ptr_nonnull(result);
ck_assert_str_eq(result, "hello  world");  // Пробелы с обоих концов удалены
free(result);

// Тест 8: Удаление смешанных символов (пробелы, табы, запятые)
#test test_trim_mixed_chars
void *result = s21_trim(" ,\t, leading and trailing ,\t, ", " ,\t");
ck_assert_ptr_nonnull(result);
ck_assert_str_eq(result,
                 "leading and trailing");  // Удаляет указанные символы с концов
free(result);

// Тест 9: Все символы строки являются символами для удаления
#test test_trim_all_chars_trimmed
void *result = s21_trim("###", "#");
ck_assert_ptr_nonnull(result);
ck_assert_str_eq(result, "");  // Должна остаться пустая строка
free(result);

// Тест 10: Строка не должна измениться (нет символов для удаления по краям)
#test test_trim_no_change
void *result = s21_trim("middle  part", "xyz");
ck_assert_ptr_nonnull(result);
ck_assert_str_eq(result, "middle  part");
free(result);

// Тест 11: Пустая строка в trim_chars (ничего не должно удаляться)
#test test_trim_empty_trim_chars
void *result = s21_trim("trim me", "");
ck_assert_ptr_nonnull(result);
ck_assert_str_eq(result, "trim me");  // Ожидаем исходную строку
free(result);

// ##################################################################### //
// ----------------------------- s21_strtok ---------------------------- //
// ##################################################################### //
char *s21_strtok_result;
char *strtok_result;

char str_strtok1[] = "one/two/three(four)five";
char str_strtok2[] = "one/two/three(four)five";
char delim[] = "/()";

s21_strtok_result = s21_strtok(str_strtok1, delim);
strtok_result = strtok(str_strtok2, delim);
while (s21_strtok_result != S21_NULL) {
  ck_assert_str_eq(s21_strtok_result, strtok_result);
  s21_strtok_result = s21_strtok(S21_NULL, delim);
  strtok_result = strtok(S21_NULL, delim);
}
